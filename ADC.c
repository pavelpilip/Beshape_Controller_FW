#include <p18cxxx.h>

#include <delays.h>

#include "util.h"

#include "a2d.h"

extern A2D_Timeout, Timeout_Counter;
BOOL A2D_Idle_Mode = FALSE, A2D_Operational_Mode = FALSE, A2D_Manual_Mode = FALSE;

void Init_ADC(char ADC_Working_Mode, BOOL Less_Greater_Mode) 
{
	
  A2D_INTFLAG = 0;
  DisableIntA2D;
  A2D_Module_Disable;
  
  ANCON1 = 0xFF; // ALL INPUTS ARE ANALOG
  ANCON2 = 0xFF; // ALL INPUTS ARE ANALOG
  ANCON3 = 0xFF; // ALL INPUTS ARE ANALOG
  ADCON1H = 0x04; // 12 BITS MODE, DECIMAL UNSIGNED 
  ADCON1L = 0x34; // AUTOMATIC SAMPLING MODE 
  ADCON2H = 0x4C; // POSITIVE VOLTAGE REFFERENCE IS VREF+, EACH CHANNEL HAS OWN BUFFER, SCAN INPUTS
  ADCON2L = 0x1C; // TRIGGER INTERRUPT EACH 8 SAMPLES
  ADCON3H = 0x0A; // A2D USES SYSTEM CLOCK, SAMPLE TIME IS 10 TAD
  ADCON3L = 0x02; // A2D CONVERSION CLOCK 3 X TOSC
  ADCON5H = 0x83; // AUTO SCAN IS ENABLED, TRIGGER INTERRUPT IF THRESHOLD DETECT SEQUENCE COMPLETED AND VALID COMPARE HAS OCCURRED 
  if (!Less_Greater_Mode) ADCON5L = 0x08; // CONVERT AND SAVE THE VALUE TO THE BUFFER, IF THE VALUE IS LESS THEN THE MATCHING VALUE 
  else ADCON5L = 0x09; // CONVERT AND SAVE THE VALUE TO THE BUFFER, IF THE VALUE IS GREATER THEN THE MATCHING VALUE
  ADCHS0H = 0x00; // SAMPLE B CONFIGURED TO CHANNEL 0, NOT RELEVANT IN SCAN MODE
  ADCHS0L = 0x00; // SAMPLE A CONFIGURED TO CHANNEL 0, NOT RELEVANT IN SCAN MODE
  ADCHIT1H = 0x00;
  ADCHIT1L = 0x00;
  ADCHIT0H = 0x00;
  ADCHIT0L = 0x00;
  switch (ADC_Working_Mode) // OPEN THE RELEVANT ADC INPUT
		{
			case IDLE: // ONLY VOLTAGE DOMAINS ARE SCANNED
				ADCSS1H = 0x00; // DO NOT SCAN CH24 - CH30
				ADCSS1L = 0xF7; // SCAN CH23 - CH20, CH18 - CH16
				ADCSS0H = 0x01; // SCAN CH8
				ADCSS0L = 0x40; // SCAN CH6
				break;
			case Manual_Working_Mode: // ONLY VOLTAGE DOMAINS AND SIGNAL AMPLITUDE BEFORE SWITCH ARE SCANNED
				ADCON1L = 0x00; // MANUAL SAMPLING MODE 
				ADCON2H = 0x48; // POSITIVE VOLTAGE REFFERENCE IS VREF+, EACH CHANNEL HAS OWN BUFFER, DON'T SCAN INPUTS
				ADCON2L = 0x00; // TRIGGER INTERRUPT EACH SAMPLE
				ADCON5H = 0x00; // AUTO SCAN IS DISABLED
				ADCON5L = 0x00; // CONVERSION DATA IS SAVED TO THE BUFFER
				ADCSS1H = 0x00; 
				ADCSS1L = 0x00; 
				ADCSS0H = 0x00; 
				ADCSS0L = 0x00; 
				break;
			case Operational_Working_Mode: // ONLY VOLTAGE DOMAINS AND AMPLIFIER SIGNALS ARE SCANNED
				ADCON2L = 0x3C; // TRIGGER INTERRUPT EACH 16 SAMPLES
				ADCSS1H = 0x00; // DO NOT SCAN CH24 - CH30
				ADCSS1L = 0xF7; // SCAN CH23 - CH20, CH18 - CH16
				ADCSS0H = 0xE1; // SCAN CH15 - CH13, CH8
				ADCSS0L = 0xE7; // SCAN CH0 - CH2, CH5 - CH7
				break;
			default:
				ADCSS1H = 0x00; // DO NOT SCAN CH24 - CH30
				ADCSS1L = 0xF7; // SCAN CH23 - CH20, CH18 - CH16
				ADCSS0H = 0x01; // SCAN CH8
				ADCSS0L = 0x40; // SCAN CH6
				break;
		}
 
 //////////////////////////////////// SETTING COMPARISON THRESHOLDS //////////////////////////////
 
 if (ADC_Working_Mode != Manual_Working_Mode)
 {
	if (!Less_Greater_Mode) // LOWER MEASUREMENT THRESHOLD
	 {
		 ADCBUF0 = AMP_FRWD_PWR_SNS_LOW_THRESHOLD2;
		 ADCBUF1 = AMP_FRWD_PWR_SNS_LOW_THRESHOLD1;
		 ADCBUF2 = AMP_RVRS_PWR_SNS_LOW_THRESHOLD2;
		 ADCBUF3 = VREF_LOW_THRESHOLD;
		 ADCBUF4 = PHN_ADC_SPR_LOW_THRESHOLD;
		 ADCBUF5 = VAC_PRESR_SENS_LOW_THRESHOLD;
		 ADCBUF6 = HP_TEC_Power_AN_LOW_THRESHOLD;
		 ADCBUF7 = AMP_TEMP_SNS_LOW_THRESHOLD;
		 ADCBUF8 = N5V_LOW_THRESHOLD;
		 ADCBUF9 = DDS1_BEFORE_SW_MSR_LOW_THRESHOLD;
		 ADCBUF10 = DDS2_BEFORE_SW_MSR_LOW_THRESHOLD;
		 ADCBUF11 = SMA1_OUT_MSR_LOW_THRESHOLD;
		 ADCBUF12 = SMA2_OUT_MSR_LOW_THRESHOLD;
		 ADCBUF13 = AMP_RVRS_PWR_SNS_LOW_THRESHOLD1;
		 ADCBUF14 = AMP_CUR_SNS_LOW_THRESHOLD2;
		 ADCBUF15 = AMP_CUR_SNS_LOW_THRESHOLD1;
		 ADCBUF16 = P3_3V_LOW_THRESHOLD;
		 ADCBUF17 = P5V_LOW_THRESHOLD;
		 ADCBUF18 = P12V_LOW_THRESHOLD;
		 ADCBUF19 = GEN_ADC1_LOW_THRESHOLD;
		 ADCBUF20 = N12V_LOW_THRESHOLD;
		 ADCBUF21 = P24V_LOW_THRESHOLD;
		 ADCBUF22 = P150V_LOW_THRESHOLD;
		 ADCBUF23 = P48V_LOW_THRESHOLD; 
	 }
	 else // UPPER MEASUREMENT THRESHOLD
	 {
		 ADCBUF0 = AMP_FRWD_PWR_SNS_HIGH_THRESHOLD2;
		 ADCBUF1 = AMP_FRWD_PWR_SNS_HIGH_THRESHOLD1;
		 ADCBUF2 = AMP_RVRS_PWR_SNS_HIGH_THRESHOLD2;
		 ADCBUF3 = VREF_HIGH_THRESHOLD;
		 ADCBUF4 = PHN_ADC_SPR_HIGH_THRESHOLD;
		 ADCBUF5 = VAC_PRESR_SENS_HIGH_THRESHOLD;
		 ADCBUF6 = HP_TEC_Power_AN_HIGH_THRESHOLD;
		 ADCBUF7 = AMP_TEMP_SNS_HIGH_THRESHOLD;
		 ADCBUF8 = N5V_HIGH_THRESHOLD;
		 ADCBUF9 = DDS1_BEFORE_SW_MSR_HIGH_THRESHOLD;
		 ADCBUF10 = DDS2_BEFORE_SW_MSR_HIGH_THRESHOLD;
		 ADCBUF11 = SMA1_OUT_MSR_HIGH_THRESHOLD;
		 ADCBUF12 = SMA2_OUT_MSR_HIGH_THRESHOLD;
		 ADCBUF13 = AMP_RVRS_PWR_SNS_HIGH_THRESHOLD1;
		 ADCBUF14 = AMP_CUR_SNS_HIGH_THRESHOLD2;
		 ADCBUF15 = AMP_CUR_SNS_HIGH_THRESHOLD1;
		 ADCBUF16 = P3_3V_HIGH_THRESHOLD;
		 ADCBUF17 = P5V_HIGH_THRESHOLD;
		 ADCBUF18 = P12V_HIGH_THRESHOLD;
		 ADCBUF19 = GEN_ADC1_HIGH_THRESHOLD;
		 ADCBUF20 = N12V_HIGH_THRESHOLD;
		 ADCBUF21 = P24V_HIGH_THRESHOLD;
		 ADCBUF22 = P150V_HIGH_THRESHOLD;
		 ADCBUF23 = P48V_HIGH_THRESHOLD;
	 } 
 }
  
/////////////////////////////////////////////////////////////////////////////////////////////// 
 
 /*A2D_INTFLAG = 0;
 EnableIntA2D;
 A2D_Module_Enable;*/
}

BOOL Wait_For_Completion(void)
{
	Timeout_Counter = 0;
	Timer2Enable;
	while (!A2D_Conversion_Completed)
		{
			if (A2D_Timeout) 
				{
					A2D_Timeout = FALSE;
					Timeout_Counter = 0;
					return (FALSE);
				}
		}
	Timer2Disable;
	TMR2_INTFLAG = 0; // DISABLE TIMEOUT TIMER
	RESET_TIMER2;
	Timeout_Counter = 0;
	return (TRUE);
}

void Set_A2D_Mode(char Mode) // SETTING A2D MODE 
{
	switch (Mode) 
		{
			case IDLE: 
				A2D_Idle_Mode = TRUE;
				A2D_Manual_Mode = FALSE;
				A2D_Operational_Mode = FALSE;
				break;
			case Manual_Working_Mode: 
				A2D_Idle_Mode = FALSE;
				A2D_Manual_Mode = TRUE;
				A2D_Operational_Mode = FALSE;
				break;
			case Operational_Working_Mode: 
				A2D_Idle_Mode = FALSE;
				A2D_Manual_Mode = FALSE;
				A2D_Operational_Mode = TRUE;
				break;
			default:
				A2D_Idle_Mode = TRUE;
				A2D_Manual_Mode = FALSE;
				A2D_Operational_Mode = FALSE;
				break;
		}
}

void A2D_Manual_Convert(char A2D_Channel_Number) // EXECUTE ONE CONVERSION IN MANUAL WORKING MODE
{
//	Init_ADC(Manual_Working_Mode, FALSE);
	switch (A2D_Channel_Number) // OPEN THE RELEVANT ADC INPUT
		{
			case AMP_FRWD_PWR_SNS2: 
				ADCHS0H = 0x00; // SAMPLE B CONFIGURED TO RELEVANT CHANNEL NUMBER 
				ADCHS0L = 0x00; // SAMPLE A CONFIGURED TO RELEVANT CHANNEL NUMBER 
				break;
			case AMP_FRWD_PWR_SNS1: 
				ADCHS0H = 0x01; // SAMPLE B CONFIGURED TO RELEVANT CHANNEL NUMBER 
				ADCHS0L = 0x01; // SAMPLE A CONFIGURED TO RELEVANT CHANNEL NUMBER 
				break;
			case AMP_RVRS_PWR_SNS2: 
				ADCHS0H = 0x02; // SAMPLE B CONFIGURED TO RELEVANT CHANNEL NUMBER 
				ADCHS0L = 0x02; // SAMPLE A CONFIGURED TO RELEVANT CHANNEL NUMBER 
				break;
			case PHN_ADC_SPR: 
				ADCHS0H = 0x04; // SAMPLE B CONFIGURED TO RELEVANT CHANNEL NUMBER 
				ADCHS0L = 0x04; // SAMPLE A CONFIGURED TO RELEVANT CHANNEL NUMBER 
				break;
			case VAC_PRESR_SENS: 
				ADCHS0H = 0x05; // SAMPLE B CONFIGURED TO RELEVANT CHANNEL NUMBER 
				ADCHS0L = 0x05; // SAMPLE A CONFIGURED TO RELEVANT CHANNEL NUMBER 
				break;
			case HP_TEC_Power_SNS: 
				ADCHS0H = 0x06; // SAMPLE B CONFIGURED TO RELEVANT CHANNEL NUMBER 
				ADCHS0L = 0x06; // SAMPLE A CONFIGURED TO RELEVANT CHANNEL NUMBER 
				break;
			case AMP_TEMP_SNS: 
				ADCHS0H = 0x07; // SAMPLE B CONFIGURED TO RELEVANT CHANNEL NUMBER 
				ADCHS0L = 0x07; // SAMPLE A CONFIGURED TO RELEVANT CHANNEL NUMBER 
				break;
			case N5V: 
				ADCHS0H = 0x08; // SAMPLE B CONFIGURED TO RELEVANT CHANNEL NUMBER 
				ADCHS0L = 0x08; // SAMPLE A CONFIGURED TO RELEVANT CHANNEL NUMBER 
				break;
			case DDS1_BEFORE_SW_SNS: 
				ADCHS0H = 0x09; // SAMPLE B CONFIGURED TO RELEVANT CHANNEL NUMBER 
				ADCHS0L = 0x09; // SAMPLE A CONFIGURED TO RELEVANT CHANNEL NUMBER 
				break;
			case DDS2_BEFORE_SW_SNS: 
				ADCHS0H = 0x0A; // SAMPLE B CONFIGURED TO RELEVANT CHANNEL NUMBER 
				ADCHS0L = 0x0A; // SAMPLE A CONFIGURED TO RELEVANT CHANNEL NUMBER 
				break;
			case SMA1_OUT_SNS: 
				ADCHS0H = 0x0B; // SAMPLE B CONFIGURED TO RELEVANT CHANNEL NUMBER 
				ADCHS0L = 0x0B; // SAMPLE A CONFIGURED TO RELEVANT CHANNEL NUMBER 
				break;
			case SMA2_OUT_SNS: 
				ADCHS0H = 0x0C; // SAMPLE B CONFIGURED TO RELEVANT CHANNEL NUMBER 
				ADCHS0L = 0x0C; // SAMPLE A CONFIGURED TO RELEVANT CHANNEL NUMBER 
				break;
			case AMP_RVRS_PWR_SNS1: 
				ADCHS0H = 0x0D; // SAMPLE B CONFIGURED TO RELEVANT CHANNEL NUMBER 
				ADCHS0L = 0x0D; // SAMPLE A CONFIGURED TO RELEVANT CHANNEL NUMBER 
				break;
			case AMP_CUR_SNS2: 
				ADCHS0H = 0x0E; // SAMPLE B CONFIGURED TO RELEVANT CHANNEL NUMBER 
				ADCHS0L = 0x0E; // SAMPLE A CONFIGURED TO RELEVANT CHANNEL NUMBER 
				break;
			case AMP_CUR_SNS1: 
				ADCHS0H = 0x0F; // SAMPLE B CONFIGURED TO RELEVANT CHANNEL NUMBER 
				ADCHS0L = 0x0F; // SAMPLE A CONFIGURED TO RELEVANT CHANNEL NUMBER 
				break;
			case P3_3V: 
				ADCHS0H = 0x10; // SAMPLE B CONFIGURED TO RELEVANT CHANNEL NUMBER 
				ADCHS0L = 0x10; // SAMPLE A CONFIGURED TO RELEVANT CHANNEL NUMBER 
				break;
			case P5V: 
				ADCHS0H = 0x11; // SAMPLE B CONFIGURED TO RELEVANT CHANNEL NUMBER 
				ADCHS0L = 0x11; // SAMPLE A CONFIGURED TO RELEVANT CHANNEL NUMBER 
				break;
			case P12V: 
				ADCHS0H = 0x12; // SAMPLE B CONFIGURED TO RELEVANT CHANNEL NUMBER 
				ADCHS0L = 0x12; // SAMPLE A CONFIGURED TO RELEVANT CHANNEL NUMBER 
				break;
			case GEN_ADC1: 
				ADCHS0H = 0x13; // SAMPLE B CONFIGURED TO RELEVANT CHANNEL NUMBER 
				ADCHS0L = 0x13; // SAMPLE A CONFIGURED TO RELEVANT CHANNEL NUMBER 
				break;
			case N12V: 
				ADCHS0H = 0x14; // SAMPLE B CONFIGURED TO RELEVANT CHANNEL NUMBER 
				ADCHS0L = 0x14; // SAMPLE A CONFIGURED TO RELEVANT CHANNEL NUMBER 
				break;
			case P24V: 
				ADCHS0H = 0x15; // SAMPLE B CONFIGURED TO RELEVANT CHANNEL NUMBER 
				ADCHS0L = 0x15; // SAMPLE A CONFIGURED TO RELEVANT CHANNEL NUMBER 
				break;
			case P150V: 
				ADCHS0H = 0x16; // SAMPLE B CONFIGURED TO RELEVANT CHANNEL NUMBER 
				ADCHS0L = 0x16; // SAMPLE A CONFIGURED TO RELEVANT CHANNEL NUMBER 
				break;
			case P48V: 
				ADCHS0H = 0x17; // SAMPLE B CONFIGURED TO RELEVANT CHANNEL NUMBER 
				ADCHS0L = 0x17; // SAMPLE A CONFIGURED TO RELEVANT CHANNEL NUMBER 
				break;
			default:
				ADCHS0H = 0x00; // SAMPLE B CONFIGURED TO RELEVANT CHANNEL NUMBER 
				ADCHS0L = 0x00; // SAMPLE A CONFIGURED TO RELEVANT CHANNEL NUMBER 
				break;
		}
/*	A2D_INTFLAG = 0;
	EnableIntA2D;
	A2D_Module_Enable;*/
	A2D_Sample_Start;
	PIC_PC_ACK = 1;
	Delay_6_25US(3); // 19USEC
	PIC_PC_ACK = 0;
	A2D_Convertion_Start;
}

int A2D_Value_Read(char A2D_Channel_Number) // EXECUTE ONE CONVERSION IN MANUAL WORKING MODE
{
	switch (A2D_Channel_Number) // OPEN THE RELEVANT ADC INPUT
		{
			case AMP_FRWD_PWR_SNS2: 
				return (ADCBUF0);
				break;
			case AMP_FRWD_PWR_SNS1: 
				return (ADCBUF1);
				break;
			case AMP_RVRS_PWR_SNS2: 
				return (ADCBUF2);
				break;
			case PHN_ADC_SPR: 
				return (ADCBUF4);
				break;
			case VAC_PRESR_SENS: 
				return (ADCBUF5);
				break;
			case HP_TEC_Power_SNS: 
				return (ADCBUF6);
				break;
			case AMP_TEMP_SNS: 
				return (ADCBUF7);
				break;
			case N5V: 
				return (ADCBUF8);
				break;
			case DDS1_BEFORE_SW_SNS: 
				return (ADCBUF9);
				break;
			case DDS2_BEFORE_SW_SNS: 
				return (ADCBUF10);
				break;
			case SMA1_OUT_SNS: 
				return (ADCBUF11);
				break;
			case SMA2_OUT_SNS: 
				return (ADCBUF12); 
				break;
			case AMP_RVRS_PWR_SNS1: 
				return (ADCBUF13);
				break;
			case AMP_CUR_SNS2: 
				return (ADCBUF14);
				break;
			case AMP_CUR_SNS1: 
				return (ADCBUF15);
				break;
			case P3_3V: 
				return (ADCBUF16); 
				break;
			case P5V: 
				return (ADCBUF17);
				break;
			case P12V: 
				return (ADCBUF18);
				break;
			case GEN_ADC1: 
				return (ADCBUF19);
				break;
			case N12V: 
				return (ADCBUF20);
				break;
			case P24V: 
				return (ADCBUF21);
				break;
			case P150V: 
				return (ADCBUF22);
				break;
			case P48V: 
				return (ADCBUF23);
				break;
			default:
				return (0);
				break;
		}
}

void A2D_Automatic_Convert(char ADC_Working_Mode, BOOL Less_Greater_Mode, BOOL Off_On) // EXECUTE AUTOMATIC CONVERSIONS
{
	if (Off_On)
	{
		if (Less_Greater_Mode) Init_ADC(ADC_Working_Mode, FALSE);
		else Init_ADC(ADC_Working_Mode, TRUE);
		A2D_INTFLAG = 0;
		EnableIntA2D;
		A2D_Module_Enable;
		Delay_0_625US(2); // WAIT FOR A2D MODULE ON
	}
	else
	{
		A2D_Module_Disable;
		Delay_0_625US(2); // WAIT FOR A2D MODULE OFF
		DisableIntA2D;
		A2D_INTFLAG = 0;
	}
}
